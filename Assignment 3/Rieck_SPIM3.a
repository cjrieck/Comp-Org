#-----------------------------------------------------------+
# Author: Clayton Rieck                                     |
#-----------------------------------------------------------+
# DESCRIPTION:                                              |
# This program finds the total cost of using a gas pump at  |
# Cowberland Farms and rounds the result to the nearest     |
# penny.                                                    |
#-----------------------------------------------------------+
# INPUT:                                                    |
# The user will input their payment type (S for SmahtPay,   |
# C for Credit or Q for Quitting). Then they'll enter a type|
# of gas they want to fill their car with (R for regular,   |
# P for Premium, or S for Super). Lastly, they'll enter the |
# number of gallons they'd like to fill as a single         |
# precision floating point number.                          |
#-----------------------------------------------------------+
# OUTPUT:                                                   |
# The program will output a receipt including the payment   |
# type chosen, the type of gas chosen, the number of gallons|
# they wanted to fill as a single precision floating point  |
# number, the price per gallon as a single precision float, |
# and the total cost rounded to the nearest penny and       |
# truncated to only 2 decimal places.                       |
#-----------------------------------------------------------+        
        .data
prompt:        .asciiz        "Enter a number between 0 and 44: "
test:          .asciiz        "TEST"
endl:          .asciiz        "\n"
        .text
        .globl main

# $a0-3 = arguments
# v0-1  = return values
main:
    
    # print the prompt
    la   $a0,    prompt
    li   $v0,    4
    syscall

    # read in int
    li   $v0,    5
    syscall

    # moves inputted value to $a0
    # $a0 = fib term
    move $a0,    $v0

    # $a1 = initial summation
    li   $a1,    0
    
    jal  fib

done:
    li   $v0,    10
    syscall

# --------------------------
        .data
zero:          .asciiz        "Summation: "
        .text
fib:
    # adjust stack pointer
    addi  $sp,    $sp,    -20

    # t0 = fib term
    # t1 = summation
    move  $t0,    $a0
    move  $t1,    $a1

    # if user entered 0
    bne   $t0,    $zero,    start_fib

    la    $a0,    zero    
    li    $v0,    4
    syscall
    
    # print 0
    li    $a0,    0    
    li    $v0,    1
    syscall

    la    $a0,    endl    
    li    $v0,    4
    syscall

    j     $ra

start_fib:

    # a0 = fib term
    # a1 = first fib term
    # a2 = second fib term
    # a3 = summation
    move  $a0,    $t0
    li    $a1,    0
    li    $a2,    1
    move  $a3,    $t1

    jal   smart_fib

    j     done

# --------------------------
        .data
hi_prompt:       .asciiz        "N'th Fibonacci Number: "
sum:             .asciiz        "Summation:             "
sequence:        .asciiz        "Sequence: \n"
        .text
smart_fib:
    
    # adjust stack pointer
    addi  $sp,    $sp,    -28

    # move arguments to temp registers
    # for later use
    move  $t0,    $a0
    move  $t1,    $a1
    move  $t2,    $a2
    move  $t3,    $a3
    
    # compute the sum (sum = sum + second_arg)
    add   $t3,    $t3,    $t2

    bne   $t0,    0,      recurse
    
    move  $v0,    $t2 # return current term (1)
    move  $v1,    $t3 # return current sum (0+1)
    add   $sp,    $sp,    28
    j     $ra

recurse: 

    # p1+p2
    add   $t4,    $t2,    $t1
    
    # store local variables in frame
    sw    $t0,    0($sp)  # store fib term
    sw    $t2,    4($sp)  # store p2
    sw    $t4,    8($sp)  # store p1 + p2
    sw    $t3,    12($sp) # store summation
    sw    $ra,    16($sp) # store return address

    sw    $t2,    20($sp)
    sw    $t3,    24($sp)

    # n = n - 1
    addi  $t0,    $t0,    -1

    # smart_fib(n-1, p2, p2+p1, summation)
    move  $a0,    $t0
    move  $a1,    $t2
    move  $a2,    $t4
    move  $a3,    $t3

    jal   smart_fib

    # move down the stack

    lw   $t1,    0($sp) # fib term (n)

    # if n doesn't equal 1
    # just print out next fib number in
    # the sequence
    bne   $t1,   1,    move_down

    la    $a0,    endl    
    li    $v0,    4
    syscall

    la    $a0,    hi_prompt    
    li    $v0,    4
    syscall
    
    # print p2 (fib number at n'th position)
    lw    $a0,    4($sp)    
    li    $v0,    1
    syscall

    la    $a0,    endl    
    li    $v0,    4
    syscall

    la    $a0,    sum    
    li    $v0,    4
    syscall

    # print current summation
    lw    $a0,    12($sp)    
    li    $v0,    1
    syscall

    la    $a0,    endl    
    li    $v0,    4
    syscall

    la    $a0,    endl    
    li    $v0,    4
    syscall
    
    # print sequence prompt
    la    $a0,    sequence    
    li    $v0,    4
    syscall

move_down:

    # load current fib number into a0
    # to be printed
    lw    $a0,    4($sp)    
    li    $v0,    1
    syscall

    la    $a0,    endl    
    li    $v0,    4
    syscall

    # load back the return address for 
    # the last call
    lw    $ra,    16($sp)

    # adjust the stack pointer
    addi  $sp,    $sp,     28

    j     $ra
