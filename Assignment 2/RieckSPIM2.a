    .data
integer:       .word      0
done_prompt:   .asciiz    "\nThank you for choosing Cowberland Farms! Have a great day!"
endl:          .asciiz    "\n"    
    .text
    .globl main

main:

transaction_start:
    # jump to paymentAndType procedure
	jal    getPaymentAndType


    mov.s $f12,    $f0 # amount of gallons user wants
    mov.s $f13,    $f1 # price per gallon

	# jump to getGasAmount procedure
    jal    getGasAmount

    j      transaction_start

done:

    la    $a0,    done_prompt

    li    $v0,    4
    syscall

    li    $v0,    10
    syscall


# -------------------------------------------- #
# getPaymentAndType procedure
# -------------------------------------------- #
    .data
pay_prompt:           .asciiz    "Please enter a payment type\n's': SmahtPay\n'c': Credit\n'q': Complete Transaction\n> "
gas_prompt:           .asciiz    "Please choose gas type:\nType        Code    Price\nRegular      R      3.619\nPlus         P      3.719\nSuper        S      3.839\n> "
gas_amount_prompt:    .asciiz    "\nPlease enter how many gallons of gas you'd like:\n> "    
    .text

getPaymentAndType:
    
    # ascii values for 'Q' and 'q' respectively
    li    $t0,    81
    li    $t1,    113

    # ascii values for 'S' and 's' respectively
    li    $t2,    83
    li    $t3,    115

    # ascii values for 'C' and 'c' respectively
    li    $t4,    67
    li    $t5,    99

	# display payment prompt
    la    $a0,    pay_prompt

    li    $v0,    4
    syscall

    # read in a character
    li    $v0,    12
    syscall

    # move character read in into $t1
    move  $s0,    $v0

    # check if input is 'Q' or 'q'
    beq    $s0,    $t0,    done
    beq    $s0,    $t1,    done

    la    $a0,    endl

    li    $v0,    4
    syscall

    # display payment prompt
    la    $a0,    gas_prompt

    li    $v0,    4
    syscall

    # read in a character
    li    $v0,    12
    syscall

    move  $s1,    $v0

    # s0 = payment type
    # s1 = gas type

    # store price of gas type
    # 'S' already stored in $t2
    li    $t6,    82    # ascii value for 'R'
    li    $t7,    80    # ascii value for 'P'

    beq   $s1,    $t6,    regular    # get price for regular gas
    beq   $s1,    $t7,    plus       # get price for plus gas
    beq   $s1,    $t2,    super      # get price for super gas

    # set the price depending on the gas the user chose
regular:
    li.s  $f21,   3.619
    j     amount

plus:
    li.s  $f21,   3.719
    j     amount

super:
    li.s  $f21,   3.839
    j     amount

amount:

    # check if not using SmahtPay
    beq   $s0,    $t4,    no_discount
    beq   $s0,    $t5,    no_discount

    li.s  $f24,    0.1

    # give 10 cent discount per gallon if using SmahtPay
    sub.s $f21,   $f21,    $f24

no_discount:
    # ask for the amount of gas they want
    la    $a0,    gas_amount_prompt

    li    $v0,    4
    syscall

    # read in float for gallons
    li    $v0,    6
    syscall

    # mov.s $f20,   $f0
    mov.s   $f1,    $f21
    # f20 = gallons of gas user wants

    j    $ra

# -------------------------------------------- #
# getGasAmount procedure
# -------------------------------------------- #
    .data
dot:         .asciiz        "."
    .text

getGasAmount:

    #f20 = gallons
    #f21 = price

    mov.s    $f20,    $f0
    mov.s    $f21,    $f1

    la    $a0,    endl
    li    $v0,    4
    syscall

    # ascii values for 'S' and 's' respectively
    li    $t2,    83
    li    $t3,    115

    mul.s $f22,   $f21,    $f20

    # f22 = price NOT ROUNDED

    # --------- start truncating decimal points ---------
    # multiply by 100.0
    li.s  $f5,    100.0
    mul.s $f22,   $f22,    $f5

    # add 0.5
    li.s  $f5,    0.5
    add.s $f22,   $f22,    $f5

    cvt.w.s $f22,  $f22 # convert single precision to int

    s.s   $f22,    integer
    
    lw    $t0,     integer

    li    $t1,    100
    div   $t0,    $t1

    mflo  $t1
    mfhi  $t2

    # $t0 = left hand side of decimal
    # $t1 = right hand side of decimal
    
    # $t0 = integer value of price

    move  $a0,   $t1
    li    $v0,    1
    syscall

    la    $a0,    dot
    li    $v0,    4
    syscall

    # checks if price is 0.0
    # if it is then add another 0 to right hand side
    # else, print remainder
    bne   $t2,    $zero,     not_zero

    li    $a0,    0
    li    $v0,    1
    syscall

not_zero:
    move  $a0,   $t2
    li    $v0,    1
    syscall

    la    $a0,    endl
    li    $v0,    4
    syscall

    j     $ra