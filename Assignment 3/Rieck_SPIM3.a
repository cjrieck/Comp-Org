        .data
prompt:        .asciiz        "Enter a number between 0 and 44: "
test:          .asciiz        "TEST"
endl:          .asciiz        "\n"
        .text
        .globl main

# $a0-3 = arguments
# v0-1  = return values
main:
    
    # print the prompt
    lw   $a0,    prompt
    li   $v0,    4
    syscall

    # read in int
    li   $v0,    5
    syscall

    # moves inputted value to $a0
    # $a0 = fib term
    move $a0,    $v0

    # $a1 = initial summation
    li   $a1,    0
    
    jal  fib

done:
    li   $v0,    10
    syscall

# --------------------------
        .data
        .text
fib:
    move  $t0,    $a0
    move  $t1,    $a1

    # t0 = fib term
    # t1 = summation

    bne   $t0,    $zero,    start_fib

    # move fib term and sum to return registers
    move  $v0,    $t0
    move  $v1,    $t1
    j     $ra

start_fib:
    # a0 = fib term
    # a1 = first fib term
    # a2 = second fib term
    # a3 = summation
    move  $a0,    $t0
    li    $a1,    0
    li    $a2,    1
    move  $a3,    $t1

    jal   smart_fib

# --------------------------
        .data
hi_prompt:       .asciiz        "nth number: "
        .text
smart_fib:
    
    # adjust stack pointer
    addi  $sp,    $sp,    -20

    # move arguments to temp registers
    # for later use
    move  $t0,    $a0
    move  $t1,    $a1
    move  $t2,    $a2
    move  $t3,    $a3
    
    #print out current fib term number (p2) => will give fib numbers in order

    # compute the sum (sum = sum + second_arg)
    add   $t3,    $t3,    $t2

    bne   $t0,    1,      recurse
    
    move  $v0,    $t2 # return current term (1)
    move  $v1,    $t3 # return current sum (0+1)
    add   $sp,    $sp,    20
    j     $ra

recurse:
    # n = n - 1
    addi  $t0,    $t0,    -1 

    # p1+p2
    add   $t4,    $t2,    $t1
    
    # store local variables in frame
    sw    $t0,    0($sp)  # store fib term
    sw    $t2,    4($sp)  # store p2
    sw    $t4,    8($sp)  # store p1 + p2
    sw    $t3,    12($sp) # store summation
    sw    $ra,    16($sp) # store return address

    # smart_fib(n-1, p2, p2+p1, summation)
    move  $a0,    $t0
    move  $a1,    $t2
    move  $a2,    $t4
    move  $a3,    $t3

    jal   smart_fib

    # move down the stack
    #lw    $t5,    4($sp)

    # print p2 (highest fib number)
    lw    $a0,    hi_prompt    
    li    $v0,    4
    syscall

    lw    $a0,    4($sp)    
    li    $v0,    1
    syscall

    lw    $a0,    endl    
    li    $v0,    4
    syscall

    lw    $v0,    4($sp)  # return p2
    lw    $v1,    12($sp) # return summation

    lw    $ra,    16($sp) # load return value

    addi  $sp,    $sp,     20

    j     $ra
    